<!DOCTYPE html>
<html lang="zh-Hant-TW">
<head>
    <meta charset="UTF-8">
    <title>Festival - Project Zero</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <style>
        .content { background: #000 !important; padding: 0 !important; position: relative; display: flex; overflow: hidden; }
        #output_canvas { width: 100%; height: 100%; object-fit: contain; z-index: 5; }
        video { display: none; }
        .festival-ui { position: absolute; top: 20px; left: 20px; z-index: 10; color: #00F9C7; pointer-events: none; }
    </style>
</head>
<body>
<div class="header"><div class="title">Project Zero / é›¶è¨ˆç•«</div><div class="numbers">Festival Mode</div></div>
<div class="layout">
    <div class="sidebar">
        <a href="home.html">è‡ªä»‹</a><a href="diary.html">æ—¥è¨˜</a><a href="blog.html">éƒ¨è½æ ¼</a>
        <a href="gallery.html">ç›¸ç°¿</a><a href="collections.html">æ”¶è—</a>
        <a href="fortune.html">å¹¸é‹æŒ‡æ•¸</a><a href="festival.html">ç¯€æ…¶</a>
    </div>
    <div class="content">
        <div class="festival-ui">
            <h2>2025 New Year Event</h2>
            <p>âœŠ æ¡æ‹³ï¼šç²’å­åŒ¯èš<br>ğŸ–ï¸ å¼µæ‰‹ï¼šç²’å­æ•£é–‹</p>
        </div>
        <video id="input_video" playsinline></video>
        <canvas id="output_canvas"></canvas>
    </div>
</div>

<script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    let particles = [], textPoints = [], isFist = false;
    let currentHand = { x: 0.5, y: 0.5 };

    // 1. åˆå§‹åŒ–å­—é«”åº§æ¨™
    function initText() {
        const tCanvas = document.createElement('canvas');
        const tCtx = tCanvas.getContext('2d');
        tCanvas.width = 800; tCanvas.height = 200;
        tCtx.fillStyle = "white"; tCtx.font = "bold 80px Arial";
        tCtx.textAlign = "center"; tCtx.fillText("HAPPY NEW YEAR", 400, 100);
        const data = tCtx.getImageData(0, 0, 800, 200).data;
        for (let y = 0; y < 200; y += 5) {
            for (let x = 0; x < 800; x += 5) {
                if (data[(y * 800 + x) * 4 + 3] > 128) {
                    textPoints.push({ x: x - 400, y: y - 100 });
                }
            }
        }
    }

    // 2. ç²’å­é¡åˆ¥ (æ•´åˆç‰©ç†ç´„æŸèˆ‡é–ƒçˆæ•ˆæœ)
    class Particle {
        constructor() {
            this.x = Math.random() * 800;
            this.y = Math.random() * 600;
            this.v = { x: (Math.random() - 0.5) * 5, y: (Math.random() - 0.5) * 5 };
            this.baseHue = Math.random() * 40 + 160; // è–„è·ç¶ è‰²ç³»
            this.brightness = Math.random() * 50 + 50;
        }

        update() {
            const canvasW = canvasElement.width;
            const canvasH = canvasElement.height;

            if (isFist) {
                // æ¡æ‹³ï¼šå¼·åŠ›åŒ¯èš
                let index = particles.indexOf(this);
                let pt = textPoints[index % textPoints.length];
                let tx = currentHand.x * canvasW + pt.x;
                let ty = currentHand.y * canvasH + pt.y;
                
                this.x += (tx - this.x) * 0.22; // æé«˜æ­¸ä½é€Ÿåº¦
                this.y += (ty - this.y) * 0.22;
                this.brightness = Math.random() * 40 + 60; // åŒ¯èšæ™‚é–ƒçˆ
            } else {
                // å¼µæ‰‹ï¼šæ•£é–‹ä½†å—ã€Œå‘å¿ƒåŠ›ã€ç´„æŸ
                this.x += this.v.x;
                this.y += this.v.y;

                let dx = this.x - (currentHand.x * canvasW);
                let dy = this.y - (currentHand.y * canvasH);
                let dist = Math.hypot(dx, dy);

                // å¦‚æœè·‘å¤ªé  (è¶…é350px)ï¼Œå°±æ–½åŠ æ‹‰åŠ›æ‹‰å›æ‰‹å¿ƒé™„è¿‘
                if (dist > 350) {
                    this.v.x -= dx * 0.015;
                    this.v.y -= dy * 0.015;
                }

                this.brightness = 50; // æ•£é–‹æ™‚äº®åº¦ç©©å®š
                
                // é‚Šç•Œå›å½ˆ
                if (this.x < 0 || this.x > canvasW) this.v.x *= -1;
                if (this.y < 0 || this.y > canvasH) this.v.y *= -1;
            }
        }

        draw() {
            canvasCtx.fillStyle = `hsl(${this.baseHue}, 100%, ${this.brightness}%)`;
            canvasCtx.beginPath();
            // æ¡æ‹³æ™‚ç¨å¾®è®Šå¤§ï¼Œå¢åŠ å­—é«”åšåº¦
            canvasCtx.arc(this.x, this.y, isFist ? 2.2 : 1.5, 0, Math.PI * 2);
            canvasCtx.fill();
        }
    }

    // åˆå§‹åŒ–èˆ‡åŸ·è¡Œ
    initText();
    for (let i = 0; i < 700; i++) particles.push(new Particle());

    function animate() {
        // å‹•æ…‹èª¿æ•´ç•«å¸ƒå°ºå¯¸é©æ‡‰è¢å¹•
        if (canvasElement.width !== canvasElement.clientWidth || canvasElement.height !== canvasElement.clientHeight) {
            canvasElement.width = canvasElement.clientWidth;
            canvasElement.height = canvasElement.clientHeight;
        }

        // ä½¿ç”¨åŠé€æ˜é»‘è‰²è¦†è“‹ï¼Œç‡Ÿé€ ç²’å­æ‹–å°¾(Motion Blur)æ•ˆæœ
        canvasCtx.fillStyle = "rgba(0,0,0,0.15)";
        canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);

        particles.forEach(p => {
            p.update();
            p.draw();
        });
        requestAnimationFrame(animate);
    }
    animate();

    // 3. MediaPipe æ‰‹éƒ¨åµæ¸¬
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
    
    hands.onResults(res => {
        if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
            const h = res.multiHandLandmarks[0];
            // åˆ¤æ–·æ¡æ‹³ï¼šé£ŸæŒ‡å°–(8)èˆ‡å¤§æ‹‡æŒ‡å°–(4)çš„è·é›¢
            const dist = Math.hypot(h[8].x - h[4].x, h[8].y - h[4].y);
            isFist = dist < 0.12; // ç¨å¾®æ”¾å¯¬åˆ¤å®šï¼Œæ›´éˆæ•
            // é¡åƒè™•ç†ï¼šè®“ç•«é¢ä¸Šçš„æ‰‹è·Ÿè‘—ä½ çš„æ–¹å‘å‹•
            currentHand = { x: 1 - h[9].x, y: h[9].y };
        } else {
            isFist = false;
        }
    });

    const camera = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 1280, height: 720
    });
    camera.start().catch(() => console.error("Camera error"));
</script>
</body>
</html>
